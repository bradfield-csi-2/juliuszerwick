# Notes on pagecount.c program

## What instructions do you expect to be generated by the compiler?

I expect that the compiler will generate a `mov` instruction to move the `memory_size` value into a register and to do the same for the `page_size` value. And to perform the division calculation, I expect that a `div` instruction is generated that will divide the values of `memory_size` and `page_size` and save the value in the `rax` register so that the resultant value is the return value.

## What instructions are actually generated by the compiler?

The generated instructions are as follows:

- `pushq %rbp` to push the frame pointer onto the stack
- `movq %rsp, %rbp` to move the frame pointer register value to the stack pointer register
- `movq	%rdi, -8(%rbp)` to move the lower memory address as the stack grows downward to the `%rdi` register
- `movq	%rsi, -16(%rbp)` to move the further lower memory address as the stack grows downward to the `%rsi` register
- `movq	-8(%rbp), %rax` to move the return value in the `%rax` register to the memory address located at `-8(%rbp)`
- `xorl	%ecx, %ecx` to zero out the value stored in register `%ecx` which is the return value
- `movl	%ecx, %edx` to move the value in the `%edx` register into the return register `%ecx`
- `divq	-16(%rbp)` to divide the value stored in `%rax` by the value at `16(%rbp)`
- `popq	%rbp` to "clear the stack" by popping the frame pointer
- `retq` to return from the `_pagecount` procedure

## Is the function substantially different if you change the optimization level?

With optimization level `O1` in `gcc -S -O1 pagecount.c`, the instructions are as follows:

```
_pagecount:
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	movq	%rdi, %rax
	xorl	%edx, %edx
	divq	%rsi
	popq	%rbp
	retq
	.cfi_endproc
```

Overall, this is very similar to the instructions noted in the previous question in which I ran `gcc -S pagecount.c`. The main differences are the lack of instructions to access values in memory that are offset from the frame pointer stored in register `%rbp`.

In we use optimization level `02`, we get the following:

```
_pagecount:
	.cfi_startproc
## %bb.0:
	pushq	%rbp
	.cfi_def_cfa_offset 16
	.cfi_offset %rbp, -16
	movq	%rsp, %rbp
	.cfi_def_cfa_register %rbp
	movq	%rdi, %rax
	xorl	%edx, %edx
	divq	%rsi
	popq	%rbp
	retq
	.cfi_endproc
```

Which is the same as the instructions generated for optimization level `O1`. The function is *not* substantially different.

## godbolt.org exploration

For `x86-64 gcc 10.2` and `-O1`:

```
mov     rax, rdi
mov     edx, 0
div     rsi
ret
```


For `x86-64 clang 11.0.1` and `-01`:

```
pagecount:
mov     rax, rdi
xor     edx, edx
div     rsi
ret
```


For `ARM64 gcc 10.2` with `-O1`:

```
pagecount:
udiv    x0, x0, x1
ret
```


For `Arduino Uno 1.8.9`:

```
pagecount:
push r10
push r11
push r12
push r13
push r14
push r15
push r16
push r17
push r28
push r29
in r28,__SP_L__
in r29,__SP_H__
sbiw r28,16
in __tmp_reg__,__SREG__
cli
out __SP_H__,r29
out __SREG__,__tmp_reg__
out __SP_L__,r28
std Y+1,r18
std Y+2,r19
std Y+3,r20
std Y+4,r21
std Y+5,r22
std Y+6,r23
std Y+7,r24
std Y+8,r25
std Y+9,r10
std Y+10,r11
std Y+11,r12
std Y+12,r13
std Y+13,r14
std Y+14,r15
std Y+15,r16
std Y+16,r17
ldd r10,Y+9
ldd r11,Y+10
ldd r12,Y+11
ldd r13,Y+12
ldd r14,Y+13
ldd r15,Y+14
ldd r16,Y+15
ldd r17,Y+16
ldd r18,Y+1
ldd r19,Y+2
ldd r20,Y+3
ldd r21,Y+4
ldd r22,Y+5
ldd r23,Y+6
ldd r24,Y+7
ldd r25,Y+8
call __udivdi3
mov r10,r18
mov r11,r19
mov r12,r20
mov r13,r21
mov r14,r22
mov r15,r23
mov r16,r24
mov r17,r25
mov r18,r10
mov r19,r11
mov r20,r12
mov r21,r13
mov r22,r14
mov r23,r15
mov r24,r16
mov r25,r17
mov r10,r18
mov r11,r19
mov r12,r20
mov r13,r21
mov r14,r22
mov r15,r23
mov r16,r24
mov r17,r25
mov r18,r10
mov r19,r11
mov r20,r12
mov r21,r13
mov r22,r14
mov r23,r15
mov r24,r16
mov r25,r17
```

## Which of the generated instructions may be slow?

As a rule of thumb, anything that requires reading or writing to memory will be slow so those sort of instructions should be minimized if possible. For that reason, I believe that the `mov` instructions will impact the performance of the function.

And if I recall correctly, division is an expensive operation which could also be causing the function to be slow. So if we could replace it with an alternative operation to achieve the same effect, that could lead to an improvement.

Referencing Agner Fog's [instruction tables](https://www.agner.org/optimize/instruction_tables.pdf) for an Intel Haswell on page 229, it seems that the following instructions would be slow:

- `div` with a latency of 22-25 for an 8-bit register, 23-26 for a 16-bit register, 22-29 for a 32-bit register, and 21-74 for a 64-bit register.

In comparison, a `mov` instruction insolving two registers would have a latency of 0-1. So the `mov` instructions aren't the bottleneck for the function's performance.

## Improving performance

Given that a page size is always a power of 2 and that the size of memory will always be cleanly divisible by the page size, we could use a bit shift to replace the multiplication operation. A shift right arithmetic (`sra`) instruction has a latency of 1, so it could be at least 22x more performant than a `div` instruction.

Measurement with original version of `pagecount.c`:
```
0.07s to run 10000000 tests (6.80ns per test)
```

Measure with `sar` version of `pagecount.c`:
```
0.00s to run 10000000 tests (0.43ns per test)
```

The performance improvement was ~15x after making the change to using `sar` instead of `div`. This is a bit less than I expected, but perhaps the math for my original estimation was incorrect.

I believe that the reason the compiler couldn't make this optimization is because it can't know that the page size will always be a power of 2 and that the size of memory will always be cleanly divisible by the page size. The compiler instead chooses the "safer" route to ensure that the generated instructions will work for any type of values that the memory size and page size could be.

Odd observation: repeated runs of the `sar` version of `pagecount.c` output nonsense:
```
<optimization>$ ./pc
0.00s to run 10000000 tests (0.43ns per test)
<optimization>$ ./pc
18446744073709.55s to run 10000000 tests (1844674407370955.25ns per test)
```

